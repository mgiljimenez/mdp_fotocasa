## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-parking-ascensor-amueblado/181604157/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-ascensor-amueblado/179696038/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Instala si hace falta
# install.packages("pheatmap")
library(pheatmap)
install.packages("pheatmap")
install.packages("Rtools")
install.packages("Rtools")
# Instala si hace falta
install.packages("pheatmap")
library(pheatmap)
# Instala si hace falta
library(pheatmap)
# Instala si hace falta
library(pheatmap)
# Heatmap escalado por fila
pheatmap(contri_out,
scale = "row",      # para ver patrones relativos en cada piso
clustering_method = "ward.D2",
main = "Patrones de contribución (SCR) en pisos atípicos",
fontsize_row = 6,
fontsize_col = 8)
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-ascensor-amueblado/179696038/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Instala si hace falta
library(pheatmap)
# Heatmap escalado por fila
pheatmap(contri_out,
scale = "row",      # para ver patrones relativos en cada piso
clustering_method = "ward.D2",
main = "Patrones de contribución (SCR) en pisos atípicos",
fontsize_row = 6,
fontsize_col = 8)
# Instala si hace falta
library(pheatmap)
# 1. Identificas los índices de los pisos atípicos
atipicos <- which(mySCR > chi2lim)
# 2. Con esos índices, extraes de 'mycontris' solo las filas de los atípicos
contri_out <- mycontris[atipicos, ]
# Heatmap escalado por fila
pheatmap(contri_out,
scale = "row",      # para ver patrones relativos en cada piso
clustering_method = "ward.D2",
main = "Patrones de contribución (SCR) en pisos atípicos",
fontsize_row = 6,
fontsize_col = 8)
# Instala si hace falta
library(pheatmap)
# 1. Identificas los índices de los pisos atípicos
atipicos <- which(mySCR > chi2lim)
# 2. Con esos índices, extraes de 'mycontris' solo las filas de los atípicos
contri_out <- mycontris[atipicos, ]
# 1. PCA sobre la matriz de contribuciones (filas = pisos, cols = variables)
pca_contri <- prcomp(contri_out, scale. = TRUE)
# 2. Gráfico de varianza explicada
plot(pca_contri, type = "l", main = "Scree Plot PCA contribuciones")
# 3. Biplot de las dos primeras dimensiones
biplot(pca_contri, cex = 0.6, main = "PCA de contribuciones a SCR")
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-ascensor-amueblado/179696038/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades <- 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- mydata[atipicos, "university_count"] > umbral_universidades
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos, "university_count"] > umbral_universidades
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades <- 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- mydata[atipicos[!destacan_en_universidades], ]
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades <- 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos[!destacan_en_universidades], ]
print(pisos_no_destacan)
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-terraza-ascensor/183359140/d	",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-terraza-ascensor/183359140/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Umbral 99 %
atipicos_moderados=fotocasa$URL[ mySCR > chi2lim99 ]
atipicos_moderados
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- atipicos_moderados[atipicos, "university_count"] > umbral_universidades
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades= 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos_moderados, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos_moderados[!destacan_en_universidades], ]
print(pisos_no_destacan)
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades= 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos_moderados, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos_moderados[!destacan_en_universidades], ]
print(pisos_no_destacan[1])
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades= 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos_moderados, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos_moderados[!destacan_en_universidades], ]
print(pisos_no_destacan[0])
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/amueblado-internet/185589991/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
colnames(variables)
library(readxl)
fotocasa = read_excel("fotocasaImp.xlsx")
fotocasa <- as.data.frame(fotocasa)
rownames(fotocasa) <- fotocasa[[1]]
fotocasa
variables <- fotocasa[, c(9,10,11,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31, 32, 33)]
# Obtener nombres de columnas que terminan en '_count'
count_vars <- grep("_count$", colnames(fotocasa), value = TRUE)
# Crear nueva columna que sume todos los conteos por fila
fotocasa$entorno_score <- rowSums(fotocasa[, count_vars], na.rm = TRUE)
# Eliminar columnas originales '_count' (opcional)
fotocasa_reducido <- fotocasa[, !(colnames(fotocasa) %in% count_vars)]
fotocasa_reducido
colnames(fotocasa_reducido)
colnames(fotocasa)
colnames(fotocasa_reducido)
variables
colnames(fotocasa_reducido)
# Obtener nombres de columnas que terminan en '_count'
count_vars <- grep("_count$", colnames(fotocasa), value = TRUE)
# Crear nueva columna que sume todos los conteos por fila
fotocasa$entorno_score <- rowSums(fotocasa[, count_vars], na.rm = TRUE)
# Eliminar columnas originales '_count' (opcional)
fotocasa_reducido <- fotocasa[, !(colnames(fotocasa) %in% count_vars)]
variables_reducido <- fotocasa_reducido[, c(9, 10, 11, 13, 14, 15, 16,17,18,19,21,22,23,24,25,26,27,28)]
K=10
res.pca = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
# Obtener nombres de columnas que terminan en '_count'
count_vars <- grep("_count$", colnames(fotocasa), value = TRUE)
# Crear nueva columna que sume todos los conteos por fila
fotocasa$entorno_score <- rowSums(fotocasa[, count_vars], na.rm = TRUE)
# Eliminar columnas originales '_count' (opcional)
fotocasa_reducido <- fotocasa[, !(colnames(fotocasa) %in% count_vars)]
variables_reducido <- fotocasa_reducido[, c(9, 10, 11, 13, 14, 15, 16,17,18,19,21,22,23,24,25,26,27,28)]
K=10
res.pca_reducido = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca_reducido)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_reducido, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
K=10
res.pca_reducido = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=26)
K=10
res.pca_reducido = PCA(variables_reducido, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=26)
K=10
res.pca_reducido = PCA(variables_reducido, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=16)
eig.val <- get_eigenvalue(res.pca_reducido)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_reducido, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
summary(res.pca)
summary(res.pca_reducido)
plot(res.pca$x[,1:2], main = "Sin agrupar", col = "blue", pch = 16)
plot(res.pca$x[,1:2], main = "Sin agrupar", col = "blue", pch = 16, xlim=(0, 10))
K=3
res.pca_reducido = PCA(variables_reducido, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=16)
eig.val <- get_eigenvalue(res.pca_reducido)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_reducido, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
summary(res.pca)
summary(res.pca_reducido)
library(readxl)
fotocasa = read_excel("fotocasaImp.xlsx")
fotocasa <- as.data.frame(fotocasa)
rownames(fotocasa) <- fotocasa[[1]]
fotocasa
variables <- fotocasa[, c(9,10,11,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31, 32, 33)]
library(knitr)
library(FactoMineR)
library(factoextra)
res.pca = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = 10, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:7,])
#install.packages("caret")  # Si no lo tienes instalado
#install.packages("pls")    # Para PCA + Regresión
library(caret)
library(pls)
set.seed(123)  # Fijamos semilla para reproducibilidad
# Definir variables predictoras y variable objetivo
X <- variables[, !(names(variables) %in% c("priceAmount", "priceAmountDrop"))]  # Excluir "Precio"
Y <- variables$priceAmount  # Variable objetivo
# Configuración de validación cruzada (10-fold cross-validation)
control <- trainControl(method = "cv", number = 10)
# Entrenar modelo de regresión con PCA
modelo_pcr <- train(
priceAmount ~ .,      # Fórmula: Predecir Precio con todas las variables
data = variables[,c(1:22)],
method = "pcr",  # "pcr" = Regresión con PCA
trControl = control,
tuneLength = 10  # Probar hasta 10 componentes principales
)
# Mostrar resumen del modelo
print(modelo_pcr)
# Graficar error vs. número de componentes principales
plot(modelo_pcr)
K=3
res.pca = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
misScores = res.pca$ind$coord[,1:K]
miT2 = colSums(t(misScores**2)/eig.val[1:K,1])
I = nrow(variables)
F95 = K*(I**2 - 1)/(I*(I - K)) * qf(0.95, K, I-K)
F99 = K*(I**2 - 1)/(I*(I - K)) * qf(0.99, K, I-K)
plot(1:length(miT2), miT2, type = "p", xlab = "Pisos", ylab = "T2")
abline(h = F95, col = "orange", lty = 2, lwd = 2)
abline(h = F99, col = "red3", lty = 2, lwd = 2)
library(grid)
library(gridExtra)
p1 = fviz_pca_ind(res.pca, axes = c(1,2), geom = c("point"),
habillage = factor(miT2 > F95)) +
tune::coord_obs_pred()
p2 = fviz_pca_ind(res.pca, axes = c(1,3), geom = c("point"),
habillage = factor(miT2 > F95)) +
tune::coord_obs_pred()
grid.arrange(p1,p2, nrow = 1)
contribT2 = function (X, scores, loadings, eigenval, observ, cutoff = 2) {
# X is data matrix and must be centered (or centered and scaled if data were scaled)
misScoresNorm = t(t(scores**2) / eigenval)
misContrib = NULL
for (oo in observ) {
print(rownames(scores)[oo])
print(scores[oo,])
misPCs = which(as.numeric(misScoresNorm[oo,]) > cutoff)
lacontri = sapply(misPCs, function (cc) (scores[oo,cc]/eigenval[cc])*loadings[,cc]*X[oo,])
lacontri = rowSums((1*(sign(lacontri) == 1))*lacontri)
misContrib = cbind(misContrib, lacontri)
}
colnames(misContrib) = rownames(misScoresNorm[observ,])
return(misContrib)
}
# Recuperamos los datos utilizados en el modelo PCA, centrados y escalados
variablesCE = variables[,setdiff(colnames(variables), c("priceAmountDrop"))]
variablesCE = scale(variablesCE, center = TRUE, scale = TRUE)
X = as.matrix(variablesCE)
# Calculamos los loadings a partir de las coordenadas de las variables
# ya que la librería FactoMineR nos devuelve los loadings ponderados
# por la importancia de cada componente principal.
misLoadings = sweep(res.pca$var$coord, 2, sqrt(res.pca$eig[1:K,1]), FUN="/")
# Calculamos las contribuciones
mycontrisT2 = contribT2(X = X, scores = misScores, loadings = misLoadings,
eigenval = eig.val[1:K,1], observ = which.max(miT2),
cutoff = 2)
par(mar = c(10,2.3,3,1))
barplot(mycontrisT2[,1],las=2, #cex.names = 0.5,
main= paste0("Observación: ", rownames(variables)[which.max(miT2)]))
# Suponiendo que tienes tus scores, loadings y la cantidad de componentes que deseas usar (3 en este caso)
predicted_price = sum(scores[which.max(miT2), 1:3] * misLoadings[1:3, 1:3])
centros <- attributes(variablesCE)$`scaled:center`
escalas <- attributes(variablesCE)$`scaled:scale`
predicted_price <- predicted_price * escalas["priceAmount"] + centros["priceAmount"]
# Mostrar el resultado
predicted_price
real_price = variables$priceAmount[which.max(miT2)]  # Aquí usas el índice correspondiente
comparison = data.frame(Real_Price = real_price, Predicted_Price = predicted_price)
print(comparison)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Inmbuebles", ylim = c(0,180))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
# Umbral 99 %
atipicos_moderados=fotocasa$URL[ mySCR > chi2lim99 ]
atipicos_moderados
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/amueblado-internet/185589991/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# 2. Obtener las coordenadas (scores) de las observaciones
scores <- res.pca$ind$coord  # Estas son las coordenadas de las observaciones en el espacio PCA
# 3. Reconstrucción de las observaciones desde el espacio PCA
loadings <- res.pca$svd$U  # Cargas del PCA
reconstruccion <- scores %*% t(loadings)  # Reconstrucción de los datos
# 4. Calcular los residuos (diferencia entre los datos originales y la reconstrucción)
residuos <- variables - reconstruccion  # Diferencia entre los datos originales y la reconstrucción
# 5. Calcular el estadístico Q (suma de los residuos al cuadrado por fila)
Q_estadistico <- rowSums(residuos^2)
# 6. Calcular el umbral de atípicos basado en el percentil 95 de Q
umbral_Q <- quantile(Q_estadistico, 0.95)  # Percentil 95
# 7. Identificar las observaciones que no están bien ajustadas
datos_no_ajustados <- variables[Q_estadistico > umbral_Q, ]
# 8. Contar el número de observaciones no ajustadas
num_no_ajustados <- nrow(datos_no_ajustados)
# 9. Calcular el porcentaje de observaciones no ajustadas
porcentaje_no_ajustados <- (num_no_ajustados / nrow(variables)) * 100
# 10. Imprimir los resultados
print(paste("Número de observaciones no explicadas bien por el modelo:", num_no_ajustados))
print(paste("Porcentaje de observaciones no explicadas:", round(porcentaje_no_ajustados, 2), "%"))
print(paste("Umbral de Q para detectar datos no ajustados:", round(umbral_Q, 4)))
# 11. Graficar el estadístico Q y las observaciones no ajustadas
library(ggplot2)
ggplot(data.frame(ID = 1:nrow(variables), Q = Q_estadistico), aes(x = ID, y = Q)) +
geom_point(aes(color = ifelse(Q > umbral_Q, "No ajustado", "Bien ajustado"))) +
scale_color_manual(values = c("Bien ajustado" = "blue", "No ajustado" = "red")) +
labs(title = "Observaciones no explicadas bien por el modelo (Q)",
x = "Índice de observaciones", y = "Estadístico Q", color = "Categoría") +
theme_minimal()
anomalas = which(miT2 > F95)
anomalas
pisos_sin_anomalos=variables[-anomalas,]
library(knitr)
library(FactoMineR)
library(factoextra)
res.pca_sin_anomalos = PCA(pisos_sin_anomalos, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca_sin_anomalos)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_sin_anomalos, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
# Gráfico de las variables proyectadas en las primeras dos componentes
fviz_pca_var(res.pca, axes = c(1, 2), repel = TRUE, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
# Gráfico de las variables proyectadas en las primeras y terceras componentes
fviz_pca_var(res.pca, axes = c(1, 3), repel = TRUE, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
#no hacemos grafico de scores porque resulta ilegible.
fviz_pca_var(res.pca, axes = c(2, 3), repel = TRUE, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
