variablesCE = variables[,setdiff(colnames(variables), c("priceAmountDrop"))]
variablesCE = scale(variablesCE, center = TRUE, scale = TRUE)
X = as.matrix(variablesCE)
# Calculamos los loadings a partir de las coordenadas de las variables
# ya que la librería FactoMineR nos devuelve los loadings ponderados
# por la importancia de cada componente principal.
misLoadings = sweep(res.pca$var$coord, 2, sqrt(res.pca$eig[1:K,1]), FUN="/")
# Calculamos las contribuciones
mycontrisT2 = contribT2(X = X, scores = misScores, loadings = misLoadings,
eigenval = eig.val[1:K,1], observ = which.max(miT2),
cutoff = 2)
par(mar = c(10,2.3,3,1))
barplot(mycontrisT2[,1],las=2, #cex.names = 0.5,
main= paste0("Observación: ", rownames(variables)[which.max(miT2)]))
# Suponiendo que tienes tus scores, loadings y la cantidad de componentes que deseas usar (3 en este caso)
predicted_price = sum(scores[which.max(miT2), 1:3] * misLoadings[1:3, 1:3])
predicted_price
real_price = variables$priceAmount[which.max(miT2)]  # Aquí usas el índice correspondiente
comparison = data.frame(Real_Price = real_price, Predicted_Price = predicted_price)
print(comparison)
real_price = variablesCE$priceAmount[which.max(miT2)]  # Aquí usas el índice correspondiente
escalas
centros <- attributes(variablesCE)$`scaled:center`
escalas <- attributes(variablesCE)$`scaled:scale`
# Mostrar los valores de centros y escalas
centros
escalas
# Mostrar el resultado
predicted_price
# Mostrar el resultado
predicted_price
centros <- attributes(variablesCE)$`scaled:center`
escalas <- attributes(variablesCE)$`scaled:scale`
# Mostrar los valores de centros y escalas
# Suponiendo que 'pred_price_std' es el precio predicho centrado y escalado
predicted_price <- predicted_price * escalas["priceAmount"] + centros["priceAmount"]
# Mostrar el resultado
predicted_price
real_price = variables$priceAmount[which.max(miT2)]  # Aquí usas el índice correspondiente
comparison = data.frame(Real_Price = real_price, Predicted_Price = predicted_price)
print(comparison)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,11))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,20))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,50))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,100))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(20,250))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,250))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,200))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
myE = X - misScores %*% t(misLoadings)
mySCR = rowSums(myE^2)
plot(1:length(mySCR), mySCR, type = "l", main = "Distancia al modelo",
ylab = "SCR", xlab = "Cereales", ylim = c(0,180))
g = var(mySCR)/(2*mean(mySCR))
h = (2*mean(mySCR)^2)/var(mySCR)
chi2lim = g*qchisq(0.95, df = h)
chi2lim99 = g*qchisq(0.99, df = h)
abline(h = chi2lim, col = "orange", lty = 2, lwd = 2)
abline(h = chi2lim99, col = "red3", lty = 2, lwd = 2)
# Umbral 95 %
urls_exceden_95 <- variables$URL[ mySCR > chi2lim ]
# Umbral 99 %
urls_exceden_99 <- variables$URL[ mySCR > chi2lim99 ]
# Umbral 99 %
atipicos_moderados <- variables$URL[ mySCR > chi2lim99 ]
atipicos_moderados
# Umbral 99 %
atipicos_moderados=fotocasa$URL[ mySCR > chi2lim99 ]
atipicos_moderados
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-terraza-ascensor-amueblado/176424850/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-terraza-ascensor-amueblado/181797528/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-parking-ascensor-amueblado/181604157/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-ascensor-amueblado/179696038/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Instala si hace falta
# install.packages("pheatmap")
library(pheatmap)
install.packages("pheatmap")
install.packages("Rtools")
install.packages("Rtools")
# Instala si hace falta
install.packages("pheatmap")
library(pheatmap)
# Instala si hace falta
library(pheatmap)
# Instala si hace falta
library(pheatmap)
# Heatmap escalado por fila
pheatmap(contri_out,
scale = "row",      # para ver patrones relativos en cada piso
clustering_method = "ward.D2",
main = "Patrones de contribución (SCR) en pisos atípicos",
fontsize_row = 6,
fontsize_col = 8)
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-ascensor-amueblado/179696038/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Instala si hace falta
library(pheatmap)
# Heatmap escalado por fila
pheatmap(contri_out,
scale = "row",      # para ver patrones relativos en cada piso
clustering_method = "ward.D2",
main = "Patrones de contribución (SCR) en pisos atípicos",
fontsize_row = 6,
fontsize_col = 8)
# Instala si hace falta
library(pheatmap)
# 1. Identificas los índices de los pisos atípicos
atipicos <- which(mySCR > chi2lim)
# 2. Con esos índices, extraes de 'mycontris' solo las filas de los atípicos
contri_out <- mycontris[atipicos, ]
# Heatmap escalado por fila
pheatmap(contri_out,
scale = "row",      # para ver patrones relativos en cada piso
clustering_method = "ward.D2",
main = "Patrones de contribución (SCR) en pisos atípicos",
fontsize_row = 6,
fontsize_col = 8)
# Instala si hace falta
library(pheatmap)
# 1. Identificas los índices de los pisos atípicos
atipicos <- which(mySCR > chi2lim)
# 2. Con esos índices, extraes de 'mycontris' solo las filas de los atípicos
contri_out <- mycontris[atipicos, ]
# 1. PCA sobre la matriz de contribuciones (filas = pisos, cols = variables)
pca_contri <- prcomp(contri_out, scale. = TRUE)
# 2. Gráfico de varianza explicada
plot(pca_contri, type = "l", main = "Scree Plot PCA contribuciones")
# 3. Biplot de las dos primeras dimensiones
biplot(pca_contri, cex = 0.6, main = "PCA de contribuciones a SCR")
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-calefaccion-ascensor-amueblado/179696038/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades <- 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- mydata[atipicos, "university_count"] > umbral_universidades
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos, "university_count"] > umbral_universidades
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades <- 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- mydata[atipicos[!destacan_en_universidades], ]
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades <- 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos[!destacan_en_universidades], ]
print(pisos_no_destacan)
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-terraza-ascensor/183359140/d	",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/aire-acondicionado-terraza-ascensor/183359140/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
# Umbral 99 %
atipicos_moderados=fotocasa$URL[ mySCR > chi2lim99 ]
atipicos_moderados
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- atipicos_moderados[atipicos, "university_count"] > umbral_universidades
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades= 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos_moderados, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos_moderados[!destacan_en_universidades], ]
print(pisos_no_destacan)
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades= 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos_moderados, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos_moderados[!destacan_en_universidades], ]
print(pisos_no_destacan[1])
# Definir el umbral para destacar en universidades (puedes ajustarlo según lo que consideres un "destacar")
umbral_universidades= 3
# Filtrar los pisos atípicos por el índice 'atipicos' y comprobar si tienen un número de universidades superior al umbral
destacan_en_universidades <- variables[atipicos_moderados, "university_count"] > umbral_universidades
# Ver si todos los pisos atípicos destacan
todos_destacan <- all(destacan_en_universidades)
# Imprimir el resultado
if (todos_destacan) {
print("Todos los pisos atípicos destacan en universidades.")
} else {
print("No todos los pisos atípicos destacan en universidades.")
}
# Si quieres ver cuáles son los pisos que no destacan en universidades:
pisos_no_destacan <- variables[atipicos_moderados[!destacan_en_universidades], ]
print(pisos_no_destacan[0])
## Función para calcular las contribuciones a la SCR
ContriSCR = function(E, SCR) {
# E es la matriz de residuos del modelo
# SCR es la suma de cuadrados residual
contribucion = NULL
for (j in 1:length(SCR)){
eind<-E[j,]
signo<-sign(eind)
contri<-(signo*(eind^2)/SCR[j])*100
contribucion<-rbind(contribucion,contri)
}
rownames(contribucion) = rownames(E)
return(contribucion)
}
## Calculamos las contribuciones de todas las observaciones
mycontris = ContriSCR(E = myE, SCR = mySCR)
## Gráfico para Special_K
barplot(mycontris["https://www.fotocasa.es/es/alquiler/vivienda/valencia-capital/amueblado-internet/185589991/d",],las=2, cex.names = 0.7,
main=c('Contribuciones a SCR para un piso'))
colnames(variables)
library(readxl)
fotocasa = read_excel("fotocasaImp.xlsx")
fotocasa <- as.data.frame(fotocasa)
rownames(fotocasa) <- fotocasa[[1]]
fotocasa
variables <- fotocasa[, c(9,10,11,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31, 32, 33)]
# Obtener nombres de columnas que terminan en '_count'
count_vars <- grep("_count$", colnames(fotocasa), value = TRUE)
# Crear nueva columna que sume todos los conteos por fila
fotocasa$entorno_score <- rowSums(fotocasa[, count_vars], na.rm = TRUE)
# Eliminar columnas originales '_count' (opcional)
fotocasa_reducido <- fotocasa[, !(colnames(fotocasa) %in% count_vars)]
fotocasa_reducido
colnames(fotocasa_reducido)
colnames(fotocasa)
colnames(fotocasa_reducido)
variables
colnames(fotocasa_reducido)
# Obtener nombres de columnas que terminan en '_count'
count_vars <- grep("_count$", colnames(fotocasa), value = TRUE)
# Crear nueva columna que sume todos los conteos por fila
fotocasa$entorno_score <- rowSums(fotocasa[, count_vars], na.rm = TRUE)
# Eliminar columnas originales '_count' (opcional)
fotocasa_reducido <- fotocasa[, !(colnames(fotocasa) %in% count_vars)]
variables_reducido <- fotocasa_reducido[, c(9, 10, 11, 13, 14, 15, 16,17,18,19,21,22,23,24,25,26,27,28)]
K=10
res.pca = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
# Obtener nombres de columnas que terminan en '_count'
count_vars <- grep("_count$", colnames(fotocasa), value = TRUE)
# Crear nueva columna que sume todos los conteos por fila
fotocasa$entorno_score <- rowSums(fotocasa[, count_vars], na.rm = TRUE)
# Eliminar columnas originales '_count' (opcional)
fotocasa_reducido <- fotocasa[, !(colnames(fotocasa) %in% count_vars)]
variables_reducido <- fotocasa_reducido[, c(9, 10, 11, 13, 14, 15, 16,17,18,19,21,22,23,24,25,26,27,28)]
K=10
res.pca_reducido = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=23)
eig.val <- get_eigenvalue(res.pca_reducido)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_reducido, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
K=10
res.pca_reducido = PCA(variables, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=26)
K=10
res.pca_reducido = PCA(variables_reducido, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=26)
K=10
res.pca_reducido = PCA(variables_reducido, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=16)
eig.val <- get_eigenvalue(res.pca_reducido)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_reducido, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
summary(res.pca)
summary(res.pca_reducido)
plot(res.pca$x[,1:2], main = "Sin agrupar", col = "blue", pch = 16)
plot(res.pca$x[,1:2], main = "Sin agrupar", col = "blue", pch = 16, xlim=(0, 10))
K=3
res.pca_reducido = PCA(variables_reducido, scale.unit = TRUE, graph = FALSE, ncp = K, quanti.sup=16)
eig.val <- get_eigenvalue(res.pca_reducido)
VPmedio = 100 * (1/nrow(eig.val))
fviz_eig(res.pca_reducido, addlabels = TRUE) +
geom_hline(yintercept=VPmedio, linetype=2, color="red")
kable(eig.val[1:K,])
summary(res.pca)
summary(res.pca_reducido)
